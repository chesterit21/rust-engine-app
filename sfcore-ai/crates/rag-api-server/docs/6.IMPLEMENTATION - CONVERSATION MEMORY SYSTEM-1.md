## üöÄ IMPLEMENTATION - CONVERSATION MEMORY SYSTEM

Siap bro! Aku implement **sesuai urutan dependency flow** dari foundational layer ke application layer.

***

## üì¶ STEP 0: UPDATE CARGO.TOML

```toml
[package]
name = "rag-api-server"
version = "0.1.0"
edition = "2021"

[dependencies]
# Existing dependencies (keep all as is)
axum = "0.7"
tokio = { version = "1", features = ["full"] }
serde = { version = "1.0", features = ["derive"] }
serde_json = "1.0"
sqlx = { version = "0.8", features = ["runtime-tokio-rustls", "postgres", "chrono"] }
tower = "0.4"
tower-http = { version = "0.5", features = ["cors", "trace"] }
tracing = "0.1"
tracing-subscriber = { version = "0.3", features = ["env-filter"] }
dotenvy = "0.15"
anyhow = "1.0"
thiserror = "1.0"
chrono = { version = "0.4", features = ["serde"] }
reqwest = { version = "0.12", features = ["json", "stream"] }
futures = "0.3"
bytes = "1.5"
async-stream = "0.3"
config = "0.14"
notify = "6.1"
hmac = "0.12"
sha2 = "0.10"
hex = "0.4"
ipnetwork = "0.20"
multer = "3.1"
mime_guess = "2.0"
uuid = { version = "1.8", features = ["v4", "serde"] }

# === NEW: Conversation Memory Dependencies ===
dashmap = "6.1"                      # Thread-safe concurrent HashMap
unicode-segmentation = "1.12"         # Accurate character segmentation
sysinfo = "0.31"                     # System memory monitoring
rand = "0.8"                         # For token estimation randomization

# === OPTIONAL: Future enhancement ===
# tiktoken-rs = "0.5"                # Accurate tokenization (add later if needed)
```

***

## üìÅ STEP 1: DATA STRUCTURES (`src/services/conversation/types.rs`)

```rust
use chrono::{DateTime, Utc};
use serde::{Deserialize, Serialize};
use std::time::Instant;

/// Session ID format: yyyyMMddHHmmss concatenated with user_id
/// Example: 20260125040900123 (timestamp: 2026-01-25 04:09:00, user_id: 123)
pub type SessionId = i64;

/// OpenAI-compatible message format
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ChatMessage {
    pub role: String,      // "user" | "assistant" | "system"
    pub content: String,
}

impl ChatMessage {
    pub fn user(content: impl Into<String>) -> Self {
        Self {
            role: "user".to_string(),
            content: content.into(),
        }
    }

    pub fn assistant(content: impl Into<String>) -> Self {
        Self {
            role: "assistant".to_string(),
            content: content.into(),
        }
    }

    pub fn system(content: impl Into<String>) -> Self {
        Self {
            role: "system".to_string(),
            content: content.into(),
        }
    }
}

/// Complete conversation state stored in memory cache
#[derive(Debug, Clone)]
pub struct ConversationState {
    /// Session identifier
    pub session_id: SessionId,
    
    /// User who owns this conversation
    pub user_id: i64,
    
    /// Current document context (None if general chat)
    pub document_id: Option<i64>,
    
    /// Message history (max 10 items = 5 user+assistant pairs)
    /// Format: [{role:"user", content:"..."}, {role:"assistant", content:"..."}]
    pub messages: Vec<ChatMessage>,
    
    /// Current System prompt (includes base instruction + retrieval context)
    pub system_context: String,
    
    /// Cached summarized retrieval results (for reuse when skipping retrieval)
    pub last_retrieval_summary: String,
    
    /// Embedding of last query (for similarity comparison)
    pub last_query_embedding: Option<Vec<f32>>,
    
    /// Session creation time (for 6-hour absolute expiration)
    pub created_at: Instant,
    
    /// Last activity timestamp (for monitoring)
    pub last_activity: Instant,
    
    /// Metadata for analytics
    pub metadata: ConversationMetadata,
}

impl ConversationState {
    /// Create new conversation session
    pub fn new(session_id: SessionId, user_id: i64, document_id: Option<i64>) -> Self {
        let now = Instant::now();
        Self {
            session_id,
            user_id,
            document_id,
            messages: Vec::with_capacity(10), // Pre-allocate for 5 pairs
            system_context: String::new(),
            last_retrieval_summary: String::new(),
            last_query_embedding: None,
            created_at: now,
            last_activity: now,
            metadata: ConversationMetadata::default(),
        }
    }

    /// Check if session is expired (6 hours from creation)
    pub fn is_expired(&self) -> bool {
        const SIX_HOURS_SECS: u64 = 6 * 60 * 60;
        self.created_at.elapsed().as_secs() > SIX_HOURS_SECS
    }

    /// Update last activity timestamp
    pub fn touch(&mut self) {
        self.last_activity = Instant::now();
    }

    /// Get number of message pairs (user + assistant = 1 pair)
    pub fn message_pair_count(&self) -> usize {
        self.messages.len() / 2
    }

    /// Check if we need to enforce sliding window (>= 5 pairs)
    pub fn needs_window_enforcement(&self) -> bool {
        self.message_pair_count() >= 5
    }
}

/// Conversation metadata for analytics
#[derive(Debug, Clone, Default)]
pub struct ConversationMetadata {
    /// Total messages exchanged (user + assistant)
    pub total_messages: usize,
    
    /// Total retrieval operations performed
    pub total_retrievals: usize,
    
    /// How many times retrieval was skipped (reused context)
    pub retrieval_skipped_count: usize,
    
    /// Last known total token count
    pub total_tokens_last: usize,
}

/// System context components (for building dynamic System message)
#[derive(Debug, Clone)]
pub struct SystemContextComponents {
    /// Fixed base instruction (doesn't change)
    pub base_instruction: String,
    
    /// Dynamic retrieval context (changes per query or reused)
    pub retrieval_context: String,
    
    /// Optional metadata section (document info)
    pub metadata_section: Option<String>,
}

impl SystemContextComponents {
    /// Build complete System message content
    pub fn build(&self) -> String {
        let mut parts = vec![
            self.base_instruction.clone(),
            String::new(), // Empty line
            self.retrieval_context.clone(),
        ];

        if let Some(metadata) = &self.metadata_section {
            parts.push(String::new());
            parts.push(metadata.clone());
        }

        parts.join("\n")
    }
}

/// Token counting result
#[derive(Debug, Clone)]
pub struct TokenCount {
    pub total: usize,
    pub system_tokens: usize,
    pub history_tokens: usize,
    pub current_message_tokens: usize,
}

impl TokenCount {
    pub fn is_over_soft_limit(&self) -> bool {
        self.total > 20_000
    }

    pub fn is_over_hard_limit(&self) -> bool {
        self.total > 23_000
    }
}

/// Retrieval decision result
#[derive(Debug, Clone)]
pub enum RetrievalDecision {
    /// Need to perform new retrieval
    Retrieve {
        reason: RetrievalReason,
        context_aware: bool,  // Use weighted embedding?
    },
    /// Skip retrieval, reuse previous context
    Skip {
        reason: SkipReason,
    },
}

#[derive(Debug, Clone)]
pub enum RetrievalReason {
    FirstMessage,
    DocumentIdChanged,
    LowSimilarity(f32),  // Similarity score
}

#[derive(Debug, Clone)]
pub enum SkipReason {
    SameDocumentAndHighSimilarity(f32),
}

/// Weighted embedding configuration
#[derive(Debug, Clone)]
pub struct WeightedEmbeddingConfig {
    pub current_weight: f32,   // 0.7
    pub history_weight: f32,   // 0.3
    pub max_history_messages: usize, // Max 5
}

impl Default for WeightedEmbeddingConfig {
    fn default() -> Self {
        Self {
            current_weight: 0.7,
            history_weight: 0.3,
            max_history_messages: 5,
        }
    }
}
```

***

## üìÅ STEP 2: TOKEN COUNTER (`src/services/conversation/token_counter.rs`)

```rust
use unicode_segmentation::UnicodeSegmentation;
use rand::Rng;
use super::types::{ChatMessage, TokenCount};

/// Token counter with flexible 2-3 characters per token estimation
pub struct TokenCounter;

impl TokenCounter {
    /// Count tokens for a single text string
    /// Uses randomized 2-3 characters per token for accuracy
    pub fn count_text(text: &str) -> usize {
        if text.is_empty() {
            return 0;
        }

        // Count grapheme clusters (proper unicode handling)
        let char_count = text.graphemes(true).count();
        
        // Randomize between 2 and 3 characters per token
        let mut rng = rand::thread_rng();
        let chars_per_token = if rng.gen_bool(0.5) { 2 } else { 3 };
        
        // Calculate tokens, at least 1 token for non-empty text
        ((char_count + chars_per_token - 1) / chars_per_token).max(1)
    }

    /// Count tokens for message history
    pub fn count_messages(messages: &[ChatMessage]) -> usize {
        messages.iter()
            .map(|msg| {
                // Count role + content + formatting overhead
                Self::count_text(&msg.role) + Self::count_text(&msg.content) + 3
            })
            .sum()
    }

    /// Count total tokens for complete payload
    /// Returns detailed breakdown
    pub fn count_payload(
        system_context: &str,
        messages: &[ChatMessage],
        current_message: &str,
    ) -> TokenCount {
        let system_tokens = Self::count_text(system_context);
        let history_tokens = Self::count_messages(messages);
        let current_message_tokens = Self::count_text(current_message);

        TokenCount {
            total: system_tokens + history_tokens + current_message_tokens,
            system_tokens,
            history_tokens,
            current_message_tokens,
        }
    }

    /// Estimate tokens before building full context (fast check)
    pub fn estimate_total(
        system_approx: usize,
        messages: &[ChatMessage],
        current_message: &str,
    ) -> usize {
        system_approx 
            + Self::count_messages(messages) 
            + Self::count_text(current_message)
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_count_text() {
        let text = "Hello world";
        let tokens = TokenCounter::count_text(text);
        assert!(tokens >= 3 && tokens <= 6); // 11 chars / 2-3 = 3-6 tokens
    }

    #[test]
    fn test_count_messages() {
        let messages = vec![
            ChatMessage::user("What is RAG?"),
            ChatMessage::assistant("RAG is Retrieval-Augmented Generation"),
        ];
        let tokens = TokenCounter::count_messages(&messages);
        assert!(tokens > 0);
    }

    #[test]
    fn test_empty_text() {
        assert_eq!(TokenCounter::count_text(""), 0);
    }

    #[test]
    fn test_unicode_handling() {
        let text = "Hello ‰Ω†Â•Ω ü¶Ä";
        let tokens = TokenCounter::count_text(text);
        assert!(tokens > 0);
    }
}
```

***

## üìÅ STEP 3: MEMORY CACHE (`src/services/conversation/cache.rs`)

```rust
use dashmap::DashMap;
use std::sync::Arc;
use sysinfo::{System, SystemExt};
use tracing::{debug, info, warn};
use super::types::{SessionId, ConversationState};

/// Thread-safe in-memory conversation cache
/// Uses DashMap for lock-free concurrent access
#[derive(Clone)]
pub struct ConversationCache {
    /// Session storage: session_id -> ConversationState
    storage: Arc<DashMap<SessionId, ConversationState>>,
    
    /// System info for RAM monitoring
    system: Arc<parking_lot::Mutex<System>>,
}

impl ConversationCache {
    /// Create new cache instance
    pub fn new() -> Self {
        info!("Initializing conversation cache with DashMap");
        Self {
            storage: Arc::new(DashMap::new()),
            system: Arc::new(parking_lot::Mutex::new(System::new_all())),
        }
    }

    /// Get conversation state by session_id
    /// Returns None if not found or expired
    pub fn get(&self, session_id: SessionId) -> Option<ConversationState> {
        let entry = self.storage.get(&session_id)?;
        let state = entry.value().clone();

        // Check expiration (lazy deletion)
        if state.is_expired() {
            drop(entry); // Release read lock
            self.remove(session_id);
            debug!("Session {} expired, removed from cache", session_id);
            return None;
        }

        debug!("Retrieved session {} from cache (age: {:?})", 
            session_id, state.created_at.elapsed());
        Some(state)
    }

    /// Insert or update conversation state
    pub fn set(&self, session_id: SessionId, state: ConversationState) {
        self.storage.insert(session_id, state);
        debug!("Updated session {} in cache", session_id);
    }

    /// Remove conversation from cache
    pub fn remove(&self, session_id: SessionId) -> Option<ConversationState> {
        self.storage.remove(&session_id).map(|(_, state)| state)
    }

    /// Get number of active sessions
    pub fn len(&self) -> usize {
        self.storage.len()
    }

    /// Check if cache is empty
    pub fn is_empty(&self) -> bool {
        self.storage.is_empty()
    }

    /// Check if we can create new session (RAM limit: 90%)
    pub fn can_create_new_session(&self) -> bool {
        let mut sys = self.system.lock();
        sys.refresh_memory();

        let total_memory = sys.total_memory();
        let used_memory = sys.used_memory();
        let usage_percent = (used_memory as f64 / total_memory as f64) * 100.0;

        if usage_percent >= 90.0 {
            warn!(
                "Memory usage at {:.2}% (used: {} MB, total: {} MB), rejecting new session",
                usage_percent,
                used_memory / 1024 / 1024,
                total_memory / 1024 / 1024
            );
            return false;
        }

        debug!("Memory usage: {:.2}%, can create new session", usage_percent);
        true
    }

    /// Cleanup expired sessions (manual trigger)
    /// Returns number of sessions removed
    pub fn cleanup_expired(&self) -> usize {
        let expired_keys: Vec<SessionId> = self.storage
            .iter()
            .filter(|entry| entry.value().is_expired())
            .map(|entry| *entry.key())
            .collect();

        let count = expired_keys.len();
        for key in expired_keys {
            self.remove(key);
        }

        if count > 0 {
            info!("Cleaned up {} expired sessions", count);
        }

        count
    }

    /// Get cache statistics for monitoring
    pub fn stats(&self) -> CacheStats {
        let mut sys = self.system.lock();
        sys.refresh_memory();

        CacheStats {
            active_sessions: self.len(),
            memory_usage_mb: sys.used_memory() / 1024 / 1024,
            memory_total_mb: sys.total_memory() / 1024 / 1024,
            memory_usage_percent: (sys.used_memory() as f64 / sys.total_memory() as f64) * 100.0,
        }
    }
}

impl Default for ConversationCache {
    fn default() -> Self {
        Self::new()
    }
}

/// Cache statistics
#[derive(Debug, Clone)]
pub struct CacheStats {
    pub active_sessions: usize,
    pub memory_usage_mb: u64,
    pub memory_total_mb: u64,
    pub memory_usage_percent: f64,
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_cache_basic_operations() {
        let cache = ConversationCache::new();
        let session_id = 20260125040900123;
        let state = ConversationState::new(session_id, 123, None);

        // Insert
        cache.set(session_id, state.clone());
        assert_eq!(cache.len(), 1);

        // Get
        let retrieved = cache.get(session_id);
        assert!(retrieved.is_some());
        assert_eq!(retrieved.unwrap().session_id, session_id);

        // Remove
        cache.remove(session_id);
        assert!(cache.is_empty());
    }

    #[test]
    fn test_can_create_new_session() {
        let cache = ConversationCache::new();
        // Should always be true in test environment
        assert!(cache.can_create_new_session());
    }

    #[test]
    fn test_stats() {
        let cache = ConversationCache::new();
        let stats = cache.stats();
        assert!(stats.memory_total_mb > 0);
        assert!(stats.memory_usage_percent >= 0.0);
    }
}
```

***

## üìÅ STEP 4: SIMILARITY UTILITY (`src/utils/similarity.rs`)

```rust
use anyhow::Result;

/// Calculate cosine similarity between two embedding vectors
/// Returns value between -1.0 (opposite) and 1.0 (identical)
pub fn cosine_similarity(a: &[f32], b: &[f32]) -> Result<f32> {
    if a.len() != b.len() {
        anyhow::bail!("Vector dimensions must match: {} != {}", a.len(), b.len());
    }

    if a.is_empty() {
        anyhow::bail!("Vectors cannot be empty");
    }

    // Calculate dot product
    let dot_product: f32 = a.iter()
        .zip(b.iter())
        .map(|(x, y)| x * y)
        .sum();

    // Calculate magnitudes
    let magnitude_a: f32 = a.iter().map(|x| x * x).sum::<f32>().sqrt();
    let magnitude_b: f32 = b.iter().map(|x| x * x).sum::<f32>().sqrt();

    // Avoid division by zero
    if magnitude_a == 0.0 || magnitude_b == 0.0 {
        return Ok(0.0);
    }

    // Cosine similarity = dot / (||a|| * ||b||)
    let similarity = dot_product / (magnitude_a * magnitude_b);

    // Clamp to [-1, 1] to handle floating point errors
    Ok(similarity.clamp(-1.0, 1.0))
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_identical_vectors() {
        let a = vec![1.0, 2.0, 3.0];
        let b = vec![1.0, 2.0, 3.0];
        let sim = cosine_similarity(&a, &b).unwrap();
        assert!((sim - 1.0).abs() < 1e-6);
    }

    #[test]
    fn test_orthogonal_vectors() {
        let a = vec![1.0, 0.0];
        let b = vec![0.0, 1.0];
        let sim = cosine_similarity(&a, &b).unwrap();
        assert!(sim.abs() < 1e-6);
    }

    #[test]
    fn test_opposite_vectors() {
        let a = vec![1.0, 2.0, 3.0];
        let b = vec![-1.0, -2.0, -3.0];
        let sim = cosine_similarity(&a, &b).unwrap();
        assert!((sim + 1.0).abs() < 1e-6);
    }

    #[test]
    fn test_dimension_mismatch() {
        let a = vec![1.0, 2.0];
        let b = vec![1.0, 2.0, 3.0];
        assert!(cosine_similarity(&a, &b).is_err());
    }

    #[test]
    fn test_zero_vector() {
        let a = vec![0.0, 0.0, 0.0];
        let b = vec![1.0, 2.0, 3.0];
        let sim = cosine_similarity(&a, &b).unwrap();
        assert_eq!(sim, 0.0);
    }
}
```
