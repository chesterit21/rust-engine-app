// ============================================================================
// SSO Core - Additional Domain Entities
// File: crates/sso-core/src/domain/mod.rs
// Description: Tenant, Menu, Group entities
// ============================================================================

use chrono::{DateTime, Utc};
use serde::{Deserialize, Serialize};
use uuid::Uuid;
use validator::{Validate, ValidationError};

// ============================================================================
// TENANT APP ENTITY
// ============================================================================

#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]
#[serde(rename_all = "snake_case")]
pub enum SubscriptionPlan {
    Free,
    Basic,
    Premium,
    Enterprise,
}

impl SubscriptionPlan {
    pub fn as_str(&self) -> &'static str {
        match self {
            SubscriptionPlan::Free => "free",
            SubscriptionPlan::Basic => "basic",
            SubscriptionPlan::Premium => "premium",
            SubscriptionPlan::Enterprise => "enterprise",
        }
    }

    pub fn from_str(s: &str) -> Option<Self> {
        match s {
            "free" => Some(SubscriptionPlan::Free),
            "basic" => Some(SubscriptionPlan::Basic),
            "premium" => Some(SubscriptionPlan::Premium),
            "enterprise" => Some(SubscriptionPlan::Enterprise),
            _ => None,
        }
    }
}

#[derive(Debug, Clone, Serialize, Deserialize, Validate)]
pub struct TenantApp {
    pub id: Uuid,
    
    #[validate(length(min = 2, max = 100, message = "Tenant name must be between 2 and 100 characters"))]
    #[validate(custom(function = "validate_tenant_name"))]
    pub name: String,
    
    #[validate(length(max = 1000, message = "Description too long"))]
    pub description: Option<String>,
    
    #[validate(length(min = 2, max = 100, message = "Slug must be between 2 and 100 characters"))]
    #[validate(custom(function = "validate_slug"))]
    pub slug: String,
    
    pub is_active: bool,
    
    #[validate(range(min = 1, max = 10000, message = "Max users must be between 1 and 10000"))]
    pub max_users: i32,
    
    pub subscription_plan: SubscriptionPlan,
    pub subscription_expires_at: Option<DateTime<Utc>>,
    
    // Audit fields
    pub created_at: DateTime<Utc>,
    pub created_by: Option<Uuid>,
    pub modified_at: Option<DateTime<Utc>>,
    pub modified_by: Option<Uuid>,
    pub removed_at: Option<DateTime<Utc>>,
    pub removed_by: Option<Uuid>,
    pub approved_at: Option<DateTime<Utc>>,
    pub approved_by: Option<Uuid>,
}

impl TenantApp {
    pub fn new(
        name: String,
        description: Option<String>,
        slug: String,
        max_users: i32,
        subscription_plan: SubscriptionPlan,
        created_by: Option<Uuid>,
    ) -> Result<Self, ValidationError> {
        let tenant = Self {
            id: Uuid::new_v4(),
            name: name.trim().to_string(),
            description: description.map(|d| d.trim().to_string()),
            slug: slug.trim().to_lowercase(),
            is_active: true,
            max_users,
            subscription_plan,
            subscription_expires_at: None,
            created_at: Utc::now(),
            created_by,
            modified_at: None,
            modified_by: None,
            removed_at: None,
            removed_by: None,
            approved_at: None,
            approved_by: None,
        };

        tenant.validate()?;
        Ok(tenant)
    }

    pub fn is_subscription_active(&self) -> bool {
        if let Some(expires_at) = self.subscription_expires_at {
            expires_at > Utc::now()
        } else {
            true // No expiration means active
        }
    }

    pub fn upgrade_subscription(
        &mut self,
        plan: SubscriptionPlan,
        max_users: i32,
        expires_at: Option<DateTime<Utc>>,
        modified_by: Uuid,
    ) -> Result<(), ValidationError> {
        if max_users < 1 || max_users > 10000 {
            return Err(ValidationError::new("invalid_max_users"));
        }
        
        self.subscription_plan = plan;
        self.max_users = max_users;
        self.subscription_expires_at = expires_at;
        self.modified_at = Some(Utc::now());
        self.modified_by = Some(modified_by);
        
        Ok(())
    }

    pub fn soft_delete(&mut self, deleted_by: Uuid) {
        self.removed_at = Some(Utc::now());
        self.removed_by = Some(deleted_by);
        self.is_active = false;
    }

    pub fn is_deleted(&self) -> bool {
        self.removed_at.is_some()
    }
}

// ============================================================================
// MENU APP ENTITY
// ============================================================================

#[derive(Debug, Clone, Serialize, Deserialize, Validate)]
pub struct MenuApp {
    pub id: Uuid,
    pub client_app_id: Uuid,
    
    #[validate(length(min = 2, max = 100, message = "Menu name must be between 2 and 100 characters"))]
    #[validate(custom(function = "validate_menu_name"))]
    pub menu_name: String,
    
    #[validate(length(min = 1, max = 255, message = "Menu URL must be between 1 and 255 characters"))]
    #[validate(custom(function = "validate_menu_url"))]
    pub menu_url: String,
    
    pub parent_menu_id: Option<Uuid>,
    
    #[validate(length(max = 100, message = "Menu icon too long"))]
    pub menu_icon: Option<String>,
    
    #[validate(range(min = 1, max = 5, message = "Menu level must be between 1 and 5"))]
    pub menu_level: i32,
    
    pub menu_order: i32,
    pub is_active: bool,
    
    // Audit fields
    pub created_at: DateTime<Utc>,
    pub created_by: Option<Uuid>,
    pub modified_at: Option<DateTime<Utc>>,
    pub modified_by: Option<Uuid>,
    pub removed_at: Option<DateTime<Utc>>,
    pub removed_by: Option<Uuid>,
    pub approved_at: Option<DateTime<Utc>>,
    pub approved_by: Option<Uuid>,
}

impl MenuApp {
    pub fn new(
        client_app_id: Uuid,
        menu_name: String,
        menu_url: String,
        parent_menu_id: Option<Uuid>,
        menu_icon: Option<String>,
        menu_level: i32,
        menu_order: i32,
        created_by: Option<Uuid>,
    ) -> Result<Self, ValidationError> {
        let menu = Self {
            id: Uuid::new_v4(),
            client_app_id,
            menu_name: menu_name.trim().to_string(),
            menu_url: menu_url.trim().to_string(),
            parent_menu_id,
            menu_icon: menu_icon.map(|i| i.trim().to_string()),
            menu_level,
            menu_order,
            is_active: true,
            created_at: Utc::now(),
            created_by,
            modified_at: None,
            modified_by: None,
            removed_at: None,
            removed_by: None,
            approved_at: None,
            approved_by: None,
        };

        menu.validate()?;
        Ok(menu)
    }

    pub fn is_root_menu(&self) -> bool {
        self.parent_menu_id.is_none() && self.menu_level == 1
    }

    pub fn soft_delete(&mut self, deleted_by: Uuid) {
        self.removed_at = Some(Utc::now());
        self.removed_by = Some(deleted_by);
        self.is_active = false;
    }

    pub fn is_deleted(&self) -> bool {
        self.removed_at.is_some()
    }
}

// ============================================================================
// GROUP APP ENTITY
// ============================================================================

#[derive(Debug, Clone, Serialize, Deserialize, Validate)]
pub struct GroupApp {
    pub id: Uuid,
    pub client_app_id: Uuid,
    
    #[validate(length(min = 2, max = 100, message = "Group name must be between 2 and 100 characters"))]
    #[validate(custom(function = "validate_group_name"))]
    pub name: String,
    
    #[validate(length(max = 1000, message = "Description too long"))]
    pub description: Option<String>,
    
    pub is_active: bool,
    
    // Audit fields
    pub created_at: DateTime<Utc>,
    pub created_by: Option<Uuid>,
    pub modified_at: Option<DateTime<Utc>>,
    pub modified_by: Option<Uuid>,
    pub removed_at: Option<DateTime<Utc>>,
    pub removed_by: Option<Uuid>,
    pub approved_at: Option<DateTime<Utc>>,
    pub approved_by: Option<Uuid>,
}

impl GroupApp {
    pub fn new(
        client_app_id: Uuid,
        name: String,
        description: Option<String>,
        created_by: Option<Uuid>,
    ) -> Result<Self, ValidationError> {
        let group = Self {
            id: Uuid::new_v4(),
            client_app_id,
            name: name.trim().to_string(),
            description: description.map(|d| d.trim().to_string()),
            is_active: true,
            created_at: Utc::now(),
            created_by,
            modified_at: None,
            modified_by: None,
            removed_at: None,
            removed_by: None,
            approved_at: None,
            approved_by: None,
        };

        group.validate()?;
        Ok(group)
    }

    pub fn soft_delete(&mut self, deleted_by: Uuid) {
        self.removed_at = Some(Utc::now());
        self.removed_by = Some(deleted_by);
        self.is_active = false;
    }

    pub fn is_deleted(&self) -> bool {
        self.removed_at.is_some()
    }
}

// ============================================================================
// GROUP MENU APP (Permission Matrix)
// ============================================================================

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GroupMenuApp {
    pub id: Uuid,
    pub client_app_id: Uuid,
    pub group_app_id: Uuid,
    pub menu_app_id: Uuid,
    
    // Permission flags
    pub is_view: bool,
    pub is_add: bool,
    pub is_edit: bool,
    pub is_delete: bool,
    pub is_approve: bool,
    pub is_download: bool,
    pub is_upload: bool,
    pub is_print: bool,
    
    // Audit fields
    pub created_at: DateTime<Utc>,
    pub created_by: Option<Uuid>,
    pub modified_at: Option<DateTime<Utc>>,
    pub modified_by: Option<Uuid>,
    pub removed_at: Option<DateTime<Utc>>,
    pub removed_by: Option<Uuid>,
    pub approved_at: Option<DateTime<Utc>>,
    pub approved_by: Option<Uuid>,
}

impl GroupMenuApp {
    pub fn new(
        client_app_id: Uuid,
        group_app_id: Uuid,
        menu_app_id: Uuid,
        permissions: MenuPermissions,
        created_by: Option<Uuid>,
    ) -> Self {
        Self {
            id: Uuid::new_v4(),
            client_app_id,
            group_app_id,
            menu_app_id,
            is_view: permissions.is_view,
            is_add: permissions.is_add,
            is_edit: permissions.is_edit,
            is_delete: permissions.is_delete,
            is_approve: permissions.is_approve,
            is_download: permissions.is_download,
            is_upload: permissions.is_upload,
            is_print: permissions.is_print,
            created_at: Utc::now(),
            created_by,
            modified_at: None,
            modified_by: None,
            removed_at: None,
            removed_by: None,
            approved_at: None,
            approved_by: None,
        }
    }

    pub fn has_any_permission(&self) -> bool {
        self.is_view || self.is_add || self.is_edit || self.is_delete ||
        self.is_approve || self.is_download || self.is_upload || self.is_print
    }

    pub fn update_permissions(&mut self, permissions: MenuPermissions, modified_by: Uuid) {
        self.is_view = permissions.is_view;
        self.is_add = permissions.is_add;
        self.is_edit = permissions.is_edit;
        self.is_delete = permissions.is_delete;
        self.is_approve = permissions.is_approve;
        self.is_download = permissions.is_download;
        self.is_upload = permissions.is_upload;
        self.is_print = permissions.is_print;
        self.modified_at = Some(Utc::now());
        self.modified_by = Some(modified_by);
    }
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct MenuPermissions {
    pub is_view: bool,
    pub is_add: bool,
    pub is_edit: bool,
    pub is_delete: bool,
    pub is_approve: bool,
    pub is_download: bool,
    pub is_upload: bool,
    pub is_print: bool,
}

impl MenuPermissions {
    pub fn full_access() -> Self {
        Self {
            is_view: true,
            is_add: true,
            is_edit: true,
            is_delete: true,
            is_approve: true,
            is_download: true,
            is_upload: true,
            is_print: true,
        }
    }

    pub fn read_only() -> Self {
        Self {
            is_view: true,
            is_add: false,
            is_edit: false,
            is_delete: false,
            is_approve: false,
            is_download: true,
            is_upload: false,
            is_print: true,
        }
    }

    pub fn no_access() -> Self {
        Self {
            is_view: false,
            is_add: false,
            is_edit: false,
            is_delete: false,
            is_approve: false,
            is_download: false,
            is_upload: false,
            is_print: false,
        }
    }
}

// ============================================================================
// USER GROUP APP (User-Group Assignment)
// ============================================================================

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct UserGroupApp {
    pub id: Uuid,
    pub client_app_id: Uuid,
    pub member_user_id: Uuid,
    pub group_app_id: Uuid,
    pub is_active: bool,
    
    // Audit fields
    pub created_at: DateTime<Utc>,
    pub created_by: Option<Uuid>,
    pub modified_at: Option<DateTime<Utc>>,
    pub modified_by: Option<Uuid>,
    pub removed_at: Option<DateTime<Utc>>,
    pub removed_by: Option<Uuid>,
    pub approved_at: Option<DateTime<Utc>>,
    pub approved_by: Option<Uuid>,
}

impl UserGroupApp {
    pub fn new(
        client_app_id: Uuid,
        member_user_id: Uuid,
        group_app_id: Uuid,
        created_by: Option<Uuid>,
    ) -> Self {
        Self {
            id: Uuid::new_v4(),
            client_app_id,
            member_user_id,
            group_app_id,
            is_active: true,
            created_at: Utc::now(),
            created_by,
            modified_at: None,
            modified_by: None,
            removed_at: None,
            removed_by: None,
            approved_at: None,
            approved_by: None,
        }
    }

    pub fn deactivate(&mut self, deactivated_by: Uuid) {
        self.is_active = false;
        self.modified_at = Some(Utc::now());
        self.modified_by = Some(deactivated_by);
    }

    pub fn soft_delete(&mut self, deleted_by: Uuid) {
        self.removed_at = Some(Utc::now());
        self.removed_by = Some(deleted_by);
        self.is_active = false;
    }
}

// ============================================================================
// MEMBER USER TENANT APP (User-Tenant Relationship)
// ============================================================================

#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]
#[serde(rename_all = "lowercase")]
pub enum TenantRole {
    Owner,
    Admin,
    Member,
    Guest,
}

impl TenantRole {
    pub fn as_str(&self) -> &'static str {
        match self {
            TenantRole::Owner => "owner",
            TenantRole::Admin => "admin",
            TenantRole::Member => "member",
            TenantRole::Guest => "guest",
        }
    }

    pub fn from_str(s: &str) -> Option<Self> {
        match s {
            "owner" => Some(TenantRole::Owner),
            "admin" => Some(TenantRole::Admin),
            "member" => Some(TenantRole::Member),
            "guest" => Some(TenantRole::Guest),
            _ => None,
        }
    }
}

#[derive(Debug, Clone, Serialize, Deserialize, Validate)]
pub struct MemberUserTenantApp {
    pub id: Uuid,
    pub tenant_app_id: Uuid,
    pub member_user_id: Uuid,
    pub is_owner: bool,
    
    #[validate(custom(function = "validate_level_owner"))]
    pub level_owner: Option<i32>,
    
    pub role_in_tenant: TenantRole,
    pub joined_at: DateTime<Utc>,
    
    // Audit fields
    pub created_at: DateTime<Utc>,
    pub created_by: Option<Uuid>,
    pub modified_at: Option<DateTime<Utc>>,
    pub modified_by: Option<Uuid>,
    pub removed_at: Option<DateTime<Utc>>,
    pub removed_by: Option<Uuid>,
    pub approved_at: Option<DateTime<Utc>>,
    pub approved_by: Option<Uuid>,
}

impl MemberUserTenantApp {
    pub fn new(
        tenant_app_id: Uuid,
        member_user_id: Uuid,
        role_in_tenant: TenantRole,
        created_by: Option<Uuid>,
    ) -> Result<Self, ValidationError> {
        let relation = Self {
            id: Uuid::new_v4(),
            tenant_app_id,
            member_user_id,
            is_owner: false,
            level_owner: None,
            role_in_tenant,
            joined_at: Utc::now(),
            created_at: Utc::now(),
            created_by,
            modified_at: None,
            modified_by: None,
            removed_at: None,
            removed_by: None,
            approved_at: None,
            approved_by: None,
        };

        relation.validate()?;
        Ok(relation)
    }

    pub fn new_owner(
        tenant_app_id: Uuid,
        member_user_id: Uuid,
        level_owner: i32,
        created_by: Option<Uuid>,
    ) -> Result<Self, ValidationError> {
        if level_owner < 1 {
            return Err(ValidationError::new("level_owner_invalid"));
        }

        let relation = Self {
            id: Uuid::new_v4(),
            tenant_app_id,
            member_user_id,
            is_owner: true,
            level_owner: Some(level_owner),
            role_in_tenant: TenantRole::Owner,
            joined_at: Utc::now(),
            created_at: Utc::now(),
            created_by,
            modified_at: None,
            modified_by: None,
            removed_at: None,
            removed_by: None,
            approved_at: None,
            approved_by: None,
        };

        relation.validate()?;
        Ok(relation)
    }

    pub fn promote_to_owner(&mut self, level_owner: i32, promoted_by: Uuid) -> Result<(), ValidationError> {
        if level_owner < 1 {
            return Err(ValidationError::new("level_owner_invalid"));
        }

        self.is_owner = true;
        self.level_owner = Some(level_owner);
        self.role_in_tenant = TenantRole::Owner;
        self.modified_at = Some(Utc::now());
        self.modified_by = Some(promoted_by);

        Ok(())
    }

    pub fn demote_from_owner(&mut self, new_role: TenantRole, demoted_by: Uuid) {
        self.is_owner = false;
        self.level_owner = None;
        self.role_in_tenant = new_role;
        self.modified_at = Some(Utc::now());
        self.modified_by = Some(demoted_by);
    }

    pub fn soft_delete(&mut self, deleted_by: Uuid) {
        self.removed_at = Some(Utc::now());
        self.removed_by = Some(deleted_by);
    }

    pub fn is_deleted(&self) -> bool {
        self.removed_at.is_some()
    }
}

// ============================================================================
// VALIDATION FUNCTIONS
// ============================================================================

fn validate_tenant_name(name: &str) -> Result<(), ValidationError> {
    let trimmed = name.trim();
    
    if trimmed.is_empty() {
        return Err(ValidationError::new("tenant_name_empty"));
    }
    
    // Alphanumeric, spaces, hyphens, underscores
    let valid = trimmed.chars().all(|c| {
        c.is_alphanumeric() || c.is_whitespace() || matches!(c, '-' | '_')
    });
    
    if !valid {
        return Err(ValidationError::new("tenant_name_invalid_chars"));
    }
    
    Ok(())
}

fn validate_slug(slug: &str) -> Result<(), ValidationError> {
    let trimmed = slug.trim();
    
    if trimmed.is_empty() {
        return Err(ValidationError::new("slug_empty"));
    }
    
    // Lowercase alphanumeric and hyphens only
    let valid = trimmed.chars().all(|c| c.is_ascii_lowercase() || c.is_ascii_digit() || c == '-');
    
    if !valid {
        return Err(ValidationError::new("slug_invalid_format"));
    }
    
    if trimmed.starts_with('-') || trimmed.ends_with('-') {
        return Err(ValidationError::new("slug_hyphen_position"));
    }
    
    if trimmed.contains("--") {
        return Err(ValidationError::new("slug_consecutive_hyphens"));
    }
    
    Ok(())
}

fn validate_menu_name(name: &str) -> Result<(), ValidationError> {
    let trimmed = name.trim();
    
    if trimmed.is_empty() {
        return Err(ValidationError::new("menu_name_empty"));
    }
    
    Ok(())
}

fn validate_menu_url(url: &str) -> Result<(), ValidationError> {
    let trimmed = url.trim();
    
    if trimmed.is_empty() {
        return Err(ValidationError::new("menu_url_empty"));
    }
    
    // Must start with /
    if !trimmed.starts_with('/') {
        return Err(ValidationError::new("menu_url_invalid_format"));
    }
    
    Ok(())
}

fn validate_group_name(name: &str) -> Result<(), ValidationError> {
    let trimmed = name.trim();
    
    if trimmed.is_empty() {
        return Err(ValidationError::new("group_name_empty"));
    }
    
    Ok(())
}

fn validate_level_owner(level: &Option<i32>) -> Result<(), ValidationError> {
    if let Some(l) = level {
        if *l < 1 {
            return Err(ValidationError::new("level_owner_invalid"));
        }
    }
    Ok(())
}