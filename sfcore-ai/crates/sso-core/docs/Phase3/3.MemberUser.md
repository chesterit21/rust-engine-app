// ============================================================================
// SSO Core - Member User Entity
// File: crates/sso-core/src/domain/member_user.rs
// Description: User entity with complete validation
// ============================================================================

use chrono::{DateTime, Utc};
use serde::{Deserialize, Serialize};
use uuid::Uuid;
use validator::Validate;

/// User status enumeration
#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]
#[serde(rename_all = "snake_case")]
pub enum MemberStatus {
    NewRegister,
    WaitValidation,
    Invitation,
    Active,
    Suspended,
    Blocked,
}

impl MemberStatus {
    pub fn as_str(&self) -> &'static str {
        match self {
            MemberStatus::NewRegister => "new_register",
            MemberStatus::WaitValidation => "wait_validation",
            MemberStatus::Invitation => "invitation",
            MemberStatus::Active => "active",
            MemberStatus::Suspended => "suspended",
            MemberStatus::Blocked => "blocked",
        }
    }

    pub fn from_str(s: &str) -> Option<Self> {
        match s {
            "new_register" => Some(MemberStatus::NewRegister),
            "wait_validation" => Some(MemberStatus::WaitValidation),
            "invitation" => Some(MemberStatus::Invitation),
            "active" => Some(MemberStatus::Active),
            "suspended" => Some(MemberStatus::Suspended),
            "blocked" => Some(MemberStatus::Blocked),
            _ => None,
        }
    }
}

/// Member User entity
#[derive(Debug, Clone, Serialize, Deserialize, Validate)]
pub struct MemberUser {
    pub id: Uuid,
    
    #[validate(length(min = 2, max = 100, message = "Display name must be between 2 and 100 characters"))]
    #[validate(custom(function = "validate_display_name"))]
    pub display_name: String,
    
    #[validate(email(message = "Invalid email format"))]
    #[validate(length(max = 255, message = "Email must not exceed 255 characters"))]
    pub email: String,
    
    /// Bcrypt hashed password (NULL for OAuth-only users)
    #[validate(custom(function = "validate_password_hash"))]
    pub password: Option<String>,
    
    pub is_active: bool,
    pub is_login: bool,
    pub last_login: Option<DateTime<Utc>>,
    pub status_member: MemberStatus,
    
    #[validate(url(message = "Invalid profile image URL"))]
    #[validate(length(max = 2048, message = "Profile image URL too long"))]
    pub link_profile_image: Option<String>,
    
    pub email_verified: bool,
    
    #[validate(length(max = 20, message = "Phone number too long"))]
    #[validate(custom(function = "validate_phone_number"))]
    pub phone_number: Option<String>,
    
    // Audit fields
    pub created_at: DateTime<Utc>,
    pub created_by: Option<Uuid>,
    pub modified_at: Option<DateTime<Utc>>,
    pub modified_by: Option<Uuid>,
    pub removed_at: Option<DateTime<Utc>>,
    pub removed_by: Option<Uuid>,
    pub approved_at: Option<DateTime<Utc>>,
    pub approved_by: Option<Uuid>,
}

impl MemberUser {
    /// Create new user with validated data
    pub fn new(
        display_name: String,
        email: String,
        password: Option<String>,
    ) -> Result<Self, ValidationError> {
        let user = Self {
            id: Uuid::new_v4(),
            display_name: display_name.trim().to_string(),
            email: email.trim().to_lowercase(),
            password,
            is_active: true,
            is_login: false,
            last_login: None,
            status_member: MemberStatus::NewRegister,
            link_profile_image: None,
            email_verified: false,
            phone_number: None,
            created_at: Utc::now(),
            created_by: None,
            modified_at: None,
            modified_by: None,
            removed_at: None,
            removed_by: None,
            approved_at: None,
            approved_by: None,
        };

        user.validate()?;
        Ok(user)
    }

    /// Create user from OAuth provider
    pub fn from_oauth(
        display_name: String,
        email: String,
        profile_image: Option<String>,
    ) -> Result<Self, ValidationError> {
        let mut user = Self::new(display_name, email, None)?;
        user.link_profile_image = profile_image;
        user.email_verified = true; // OAuth emails are pre-verified
        Ok(user)
    }

    /// Check if user can login
    pub fn can_login(&self) -> bool {
        self.is_active 
            && !matches!(self.status_member, MemberStatus::Blocked | MemberStatus::Suspended)
            && self.removed_at.is_none()
    }

    /// Check if user requires email verification
    pub fn requires_email_verification(&self) -> bool {
        !self.email_verified && matches!(self.status_member, MemberStatus::NewRegister)
    }

    /// Activate user account
    pub fn activate(&mut self, activated_by: Option<Uuid>) {
        self.status_member = MemberStatus::Active;
        self.email_verified = true;
        self.approved_at = Some(Utc::now());
        self.approved_by = activated_by;
        self.modified_at = Some(Utc::now());
        self.modified_by = activated_by;
    }

    /// Suspend user account
    pub fn suspend(&mut self, suspended_by: Uuid, reason: &str) {
        self.status_member = MemberStatus::Suspended;
        self.is_active = false;
        self.modified_at = Some(Utc::now());
        self.modified_by = Some(suspended_by);
    }

    /// Block user account
    pub fn block(&mut self, blocked_by: Uuid) {
        self.status_member = MemberStatus::Blocked;
        self.is_active = false;
        self.modified_at = Some(Utc::now());
        self.modified_by = Some(blocked_by);
    }

    /// Soft delete user
    pub fn soft_delete(&mut self, deleted_by: Uuid) {
        self.removed_at = Some(Utc::now());
        self.removed_by = Some(deleted_by);
        self.is_active = false;
        self.is_login = false;
    }

    /// Update last login
    pub fn update_last_login(&mut self) {
        self.last_login = Some(Utc::now());
        self.is_login = true;
    }

    /// Logout user
    pub fn logout(&mut self) {
        self.is_login = false;
    }

    /// Check if user is soft deleted
    pub fn is_deleted(&self) -> bool {
        self.removed_at.is_some()
    }
}

// Custom validation functions
use validator::ValidationError;

fn validate_display_name(display_name: &str) -> Result<(), ValidationError> {
    let trimmed = display_name.trim();
    
    // Check for empty or whitespace only
    if trimmed.is_empty() {
        return Err(ValidationError::new("display_name_empty"));
    }
    
    // Check for invalid characters (allow letters, numbers, spaces, and common punctuation)
    let valid_chars = trimmed.chars().all(|c| {
        c.is_alphanumeric() || c.is_whitespace() || matches!(c, '-' | '_' | '.' | '\'' | ',')
    });
    
    if !valid_chars {
        return Err(ValidationError::new("display_name_invalid_chars"));
    }
    
    // Check for consecutive spaces
    if trimmed.contains("  ") {
        return Err(ValidationError::new("display_name_consecutive_spaces"));
    }
    
    Ok(())
}

fn validate_password_hash(password: &Option<String>) -> Result<(), ValidationError> {
    if let Some(pwd) = password {
        // Bcrypt hash should be 60 characters
        if pwd.len() != 60 || !pwd.starts_with("$2") {
            return Err(ValidationError::new("invalid_password_hash"));
        }
    }
    Ok(())
}

fn validate_phone_number(phone: &Option<String>) -> Result<(), ValidationError> {
    if let Some(p) = phone {
        let trimmed = p.trim();
        
        // Basic phone validation: only digits, spaces, +, -, (, )
        let valid = trimmed.chars().all(|c| {
            c.is_ascii_digit() || matches!(c, '+' | '-' | ' ' | '(' | ')')
        });
        
        if !valid {
            return Err(ValidationError::new("invalid_phone_number"));
        }
        
        // Must have at least 7 digits
        let digit_count = trimmed.chars().filter(|c| c.is_ascii_digit()).count();
        if digit_count < 7 || digit_count > 15 {
            return Err(ValidationError::new("phone_number_digit_count"));
        }
    }
    Ok(())
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_create_valid_user() {
        let user = MemberUser::new(
            "John Doe".to_string(),
            "john@example.com".to_string(),
            Some("$2b$12$LQv3c1yqBWVHxkd0LHAkCOYz6TtxMQJqhN8/LewY5GyYzNLmVF3Tm".to_string()),
        );
        assert!(user.is_ok());
    }

    #[test]
    fn test_invalid_email() {
        let user = MemberUser::new(
            "John Doe".to_string(),
            "invalid-email".to_string(),
            None,
        );
        assert!(user.is_err());
    }

    #[test]
    fn test_display_name_too_short() {
        let user = MemberUser::new(
            "J".to_string(),
            "john@example.com".to_string(),
            None,
        );
        assert!(user.is_err());
    }

    #[test]
    fn test_user_can_login() {
        let mut user = MemberUser::new(
            "John Doe".to_string(),
            "john@example.com".to_string(),
            None,
        ).unwrap();
        
        user.activate(None);
        assert!(user.can_login());
        
        user.suspend(Uuid::new_v4(), "test");
        assert!(!user.can_login());
    }

    #[test]
    fn test_soft_delete() {
        let mut user = MemberUser::new(
            "John Doe".to_string(),
            "john@example.com".to_string(),
            None,
        ).unwrap();
        
        assert!(!user.is_deleted());
        
        user.soft_delete(Uuid::new_v4());
        assert!(user.is_deleted());
        assert!(!user.can_login());
    }
}