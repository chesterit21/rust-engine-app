// ============================================================================
// SSO Core - Client App Entity
// File: crates/sso-core/src/domain/client_app.rs
// Description: Client application entity
// ============================================================================

use chrono::{DateTime, Utc};
use serde::{Deserialize, Serialize};
use uuid::Uuid;
use validator::{Validate, ValidationError};

/// Application type enumeration
#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]
#[serde(rename_all = "lowercase")]
pub enum AppType {
    Web,
    Mobile,
    Desktop,
    Api,
    Console,
}

impl AppType {
    pub fn as_str(&self) -> &'static str {
        match self {
            AppType::Web => "web",
            AppType::Mobile => "mobile",
            AppType::Desktop => "desktop",
            AppType::Api => "api",
            AppType::Console => "console",
        }
    }

    pub fn from_str(s: &str) -> Option<Self> {
        match s.to_lowercase().as_str() {
            "web" => Some(AppType::Web),
            "mobile" => Some(AppType::Mobile),
            "desktop" => Some(AppType::Desktop),
            "api" => Some(AppType::Api),
            "console" => Some(AppType::Console),
            _ => None,
        }
    }
}

/// Client Application entity
#[derive(Debug, Clone, Serialize, Deserialize, Validate)]
pub struct ClientApp {
    pub id: Uuid,
    
    #[validate(length(min = 3, max = 100, message = "Name must be between 3 and 100 characters"))]
    #[validate(custom(function = "validate_app_name"))]
    pub name: String,
    
    #[validate(length(max = 1000, message = "Description too long"))]
    pub description: Option<String>,
    
    #[validate(length(min = 3, max = 100, message = "Unique name must be between 3 and 100 characters"))]
    #[validate(custom(function = "validate_unique_name"))]
    pub unique_name: String,
    
    pub type_app: AppType,
    
    #[validate(url(message = "Invalid application URL"))]
    #[validate(length(max = 2048, message = "URL too long"))]
    pub url_app: String,
    
    /// Bcrypt hashed client secret
    #[validate(custom(function = "validate_client_secret"))]
    pub client_secret: String,
    
    #[validate(length(min = 1, message = "At least one redirect URI required"))]
    #[validate(custom(function = "validate_redirect_uris"))]
    pub redirect_uris: Vec<String>,
    
    pub is_active: bool,
    
    // Audit fields
    pub created_at: DateTime<Utc>,
    pub created_by: Option<Uuid>,
    pub modified_at: Option<DateTime<Utc>>,
    pub modified_by: Option<Uuid>,
    pub removed_at: Option<DateTime<Utc>>,
    pub removed_by: Option<Uuid>,
    pub approved_at: Option<DateTime<Utc>>,
    pub approved_by: Option<Uuid>,
}

impl ClientApp {
    /// Create new client application
    pub fn new(
        name: String,
        description: Option<String>,
        unique_name: String,
        type_app: AppType,
        url_app: String,
        client_secret: String,
        redirect_uris: Vec<String>,
        created_by: Option<Uuid>,
    ) -> Result<Self, ValidationError> {
        let app = Self {
            id: Uuid::new_v4(),
            name: name.trim().to_string(),
            description: description.map(|d| d.trim().to_string()),
            unique_name: unique_name.trim().to_lowercase(),
            type_app,
            url_app: url_app.trim().to_string(),
            client_secret,
            redirect_uris,
            is_active: true,
            created_at: Utc::now(),
            created_by,
            modified_at: None,
            modified_by: None,
            removed_at: None,
            removed_by: None,
            approved_at: None,
            approved_by: None,
        };

        app.validate()?;
        Ok(app)
    }

    /// Update application details
    pub fn update(
        &mut self,
        name: Option<String>,
        description: Option<String>,
        url_app: Option<String>,
        redirect_uris: Option<Vec<String>>,
        modified_by: Uuid,
    ) -> Result<(), ValidationError> {
        if let Some(n) = name {
            self.name = n.trim().to_string();
        }
        
        if let Some(d) = description {
            self.description = Some(d.trim().to_string());
        }
        
        if let Some(u) = url_app {
            self.url_app = u.trim().to_string();
        }
        
        if let Some(r) = redirect_uris {
            self.redirect_uris = r;
        }
        
        self.modified_at = Some(Utc::now());
        self.modified_by = Some(modified_by);
        
        self.validate()?;
        Ok(())
    }

    /// Activate application
    pub fn activate(&mut self, activated_by: Uuid) {
        self.is_active = true;
        self.approved_at = Some(Utc::now());
        self.approved_by = Some(activated_by);
        self.modified_at = Some(Utc::now());
        self.modified_by = Some(activated_by);
    }

    /// Deactivate application
    pub fn deactivate(&mut self, deactivated_by: Uuid) {
        self.is_active = false;
        self.modified_at = Some(Utc::now());
        self.modified_by = Some(deactivated_by);
    }

    /// Soft delete application
    pub fn soft_delete(&mut self, deleted_by: Uuid) {
        self.removed_at = Some(Utc::now());
        self.removed_by = Some(deleted_by);
        self.is_active = false;
    }

    /// Check if application is deleted
    pub fn is_deleted(&self) -> bool {
        self.removed_at.is_some()
    }

    /// Verify redirect URI is allowed
    pub fn is_redirect_uri_allowed(&self, uri: &str) -> bool {
        self.redirect_uris.iter().any(|allowed| {
            // Exact match or wildcard subdomain match
            allowed == uri || 
            (allowed.contains("*") && uri.ends_with(&allowed.replace("*.", "")))
        })
    }

    /// Rotate client secret
    pub fn rotate_secret(&mut self, new_secret: String, rotated_by: Uuid) -> Result<(), ValidationError> {
        // Validate new secret format
        if new_secret.len() != 60 || !new_secret.starts_with("$2") {
            return Err(ValidationError::new("invalid_client_secret"));
        }
        
        self.client_secret = new_secret;
        self.modified_at = Some(Utc::now());
        self.modified_by = Some(rotated_by);
        
        Ok(())
    }
}

// Custom validation functions

fn validate_app_name(name: &str) -> Result<(), ValidationError> {
    let trimmed = name.trim();
    
    if trimmed.is_empty() {
        return Err(ValidationError::new("app_name_empty"));
    }
    
    // Only alphanumeric, spaces, hyphens, underscores
    let valid = trimmed.chars().all(|c| {
        c.is_alphanumeric() || c.is_whitespace() || matches!(c, '-' | '_')
    });
    
    if !valid {
        return Err(ValidationError::new("app_name_invalid_chars"));
    }
    
    Ok(())
}

fn validate_unique_name(unique_name: &str) -> Result<(), ValidationError> {
    let trimmed = unique_name.trim();
    
    if trimmed.is_empty() {
        return Err(ValidationError::new("unique_name_empty"));
    }
    
    // Slug format: lowercase alphanumeric and hyphens only
    let valid = trimmed.chars().all(|c| c.is_ascii_lowercase() || c.is_ascii_digit() || c == '-');
    
    if !valid {
        return Err(ValidationError::new("unique_name_invalid_format"));
    }
    
    // Cannot start or end with hyphen
    if trimmed.starts_with('-') || trimmed.ends_with('-') {
        return Err(ValidationError::new("unique_name_hyphen_position"));
    }
    
    // Cannot have consecutive hyphens
    if trimmed.contains("--") {
        return Err(ValidationError::new("unique_name_consecutive_hyphens"));
    }
    
    Ok(())
}

fn validate_client_secret(secret: &str) -> Result<(), ValidationError> {
    // Bcrypt hash should be 60 characters
    if secret.len() != 60 || !secret.starts_with("$2") {
        return Err(ValidationError::new("invalid_client_secret"));
    }
    Ok(())
}

fn validate_redirect_uris(uris: &[String]) -> Result<(), ValidationError> {
    if uris.is_empty() {
        return Err(ValidationError::new("redirect_uris_empty"));
    }
    
    // Each URI must be valid
    for uri in uris {
        if uri.trim().is_empty() {
            return Err(ValidationError::new("redirect_uri_empty"));
        }
        
        // Basic URL validation
        if !uri.starts_with("http://") && 
           !uri.starts_with("https://") && 
           !uri.contains("://") {
            return Err(ValidationError::new("redirect_uri_invalid_scheme"));
        }
        
        // Max length check
        if uri.len() > 2048 {
            return Err(ValidationError::new("redirect_uri_too_long"));
        }
    }
    
    // Check for duplicates
    let mut seen = std::collections::HashSet::new();
    for uri in uris {
        if !seen.insert(uri) {
            return Err(ValidationError::new("redirect_uri_duplicate"));
        }
    }
    
    Ok(())
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_create_valid_client_app() {
        let app = ClientApp::new(
            "Test App".to_string(),
            Some("Test description".to_string()),
            "test-app".to_string(),
            AppType::Web,
            "https://example.com".to_string(),
            "$2b$12$LQv3c1yqBWVHxkd0LHAkCOYz6TtxMQJqhN8/LewY5GyYzNLmVF3Tm".to_string(),
            vec!["https://example.com/callback".to_string()],
            None,
        );
        assert!(app.is_ok());
    }

    #[test]
    fn test_invalid_unique_name() {
        let app = ClientApp::new(
            "Test App".to_string(),
            None,
            "Test App!".to_string(), // Invalid: uppercase and special char
            AppType::Web,
            "https://example.com".to_string(),
            "$2b$12$LQv3c1yqBWVHxkd0LHAkCOYz6TtxMQJqhN8/LewY5GyYzNLmVF3Tm".to_string(),
            vec!["https://example.com/callback".to_string()],
            None,
        );
        assert!(app.is_err());
    }

    #[test]
    fn test_redirect_uri_validation() {
        let mut app = ClientApp::new(
            "Test App".to_string(),
            None,
            "test-app".to_string(),
            AppType::Web,
            "https://example.com".to_string(),
            "$2b$12$LQv3c1yqBWVHxkd0LHAkCOYz6TtxMQJqhN8/LewY5GyYzNLmVF3Tm".to_string(),
            vec![
                "https://example.com/callback".to_string(),
                "https://*.example.com/callback".to_string(),
            ],
            None,
        ).unwrap();

        assert!(app.is_redirect_uri_allowed("https://example.com/callback"));
        assert!(app.is_redirect_uri_allowed("https://sub.example.com/callback"));
        assert!(!app.is_redirect_uri_allowed("https://evil.com/callback"));
    }
}